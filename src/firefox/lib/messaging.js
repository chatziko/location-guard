/**
 * (c) 2013 Rob Wu <gwnRob@gmail.com>
 * Implementation of event routing: page -> content script -> main and back.
 * Distributed under the MIT license.
 */

/*jshint browser:true*/
/*globals self*/
'use strict';

// This file is intended to be used as a module and as a content script
// See documentation for details.

if (typeof exports == 'object') { // Main
    exports.createMessageChannel = createMessageChannel;
    exports.messageContentScriptFile = module.uri;
} else if (self.port) { // Content script
    createMessageChannel(self.options, self.port);
} else {
    throw new Error('Fatal error in messaging module: Context unknown!');
}

// Usage:
// Main / content script
// argument 0: options:
// - required String channelName : Used as an unique identifier for the event propagation
// - optional boolean endAtPage : Whether to end the channel at the page or not.
//                                Defaults to false, which means that the communication
//                                channel ends at the page, ie. the global "extension"
//                                object is defined at the page and not at the content
//                                script. If endsAtPage is true, then the message
//                                channel is set up between the content script and
//                                the main script, the page is never touched at all.
// argument 1: port:
// - optional self.port, pagemod port, ..    (not needed for context=page)
//                                This value is actually required, but can be set later.
//                                If you use the channel before the port is set, the messages
//                                will be lost.

// Page (config generated by content script):
// argument 0: options
// - required String channelName : Used as an unique identifier for the event propagation
function createMessageChannel(options, port) {
    var { channelName, endAtPage } = options;

    if (typeof channelName != 'string') throw new Error('createMessageChannel: channelName must be a string!');
    channelName = channelName.replace(/^(message-router-)?/, 'message-router-'); // Ensure prefix
    endAtPage = endAtPage !== false;

    const CONTEXT = typeof exports == 'object' ? 'main' :
                    typeof self == 'object' && typeof self.port == 'object' ? 'content script' :
                    typeof document == 'object' ? 'page' : 'unknown';
    if (CONTEXT == 'unknown') throw new Error('Fatal error in messaging module: Context unknown!!');

    // If endAtPage == true then the content script just passes the messages back and forth
    // without handling the content.
    const isBetweenChannelEnds = endAtPage && CONTEXT == 'content script';
    const isAtBottomOfChannel = endAtPage ? CONTEXT == 'page' : CONTEXT == 'content script';

    // Generate random suffix for content script-page communication to avoid conflicts
    const channelSuffix = CONTEXT == 'content script' ? ''+Math.random() : '';
    // Generate random identifier to track the path of a message during the routing
    const THIS_CHANNEL_ID = Math.random();
    
    var setTimeout = typeof window == 'undefined' ? require('sdk/timers').setTimeout : window.setTimeout;
    const throw_async = function(e) setTimeout(function() { throw e; }, 0);


    var _callbacks = [];
    var stack = [];

    /* No closures within this function. */
    function dispatchEvent(data, sendResponseID) {
        /* only allow JSON-serializable data */
        data = JSON.stringify(data);
        var callbacks = _callbacks.slice(0);
        stack.push({data: data, callbacks: callbacks, sendResponseID: sendResponseID});

        if (stack.length === 1) {
            /* Stack was empty, so initiate dispatch.
             * If stack was not empty, the loop condition will ensure that the event is dispatched correctly */
            while (stack.length > 0) {
                data = stack.shift();
                callbacks = data.callbacks;
                var _sendResponse = sendResponse.bind(null, data.sendResponseID);
                data = data.data;
                var keepAlive = false;
                for (var callback of callbacks) {
                    try {
                        var res = true === callback(/*message*/JSON.parse(data), /*sender*/null, _sendResponse);
                        keepAlive = keepAlive || res;
                    } catch (e) {
                        throw_async(e);
                    }
                }
                if (!keepAlive) {
                    // None of the callbacks returned true.
                    // Initiate a message transport to make sure that the callback is called
                    // If _sendResponse was called before, this call will be a NOOP.
                    _sendResponse();
                }
            }
        }
    }

    var packagePaths = {};
    // Change undefined to null
    function JSON_stringify(obj) {
        return JSON.stringify(obj, function(key, value) {
            if (value === undefined) return null;
            return value;
        });
    }
    function sendResponse(sendResponseID, response) {
        if (!sendResponseID) return;
        var path = packagePaths[sendResponseID];
        if (!path) return;
        response = JSON_stringify(response);
        delete packagePaths[sendResponseID];
        var packet = { 
            path: path, 
            direction:  CONTEXT == 'main' ? 'down' : 'up',
            isResponse: true,
            messageID: sendResponseID,
            message: response
        };  
        deliverPacket(packet);
    }

    const onMessage = {
        addListener: function(func) {
            if (typeof func != 'function') throw new Error('onMessage.addListener expected a function!');
            _callbacks.push(func);
        },
        removeListener: function(callback) {
            var i = _callbacks.indexOf(callback);
            if (~i) _callbacks.splice(i, 1);
        },
        dispatch: dispatchEvent,
        destroy_: function() _callbacks.length = 0
    };
    const extension = {
        sendMessage: sendMessage,
        onMessage: onMessage
    };

    var response_callbacks = [];
    function sendMessage(message, callback) {
        if (callback && typeof callback != 'function')
            throw new Error('Usage: extension.sendMessage(any message, function callback)');

        var messageID;
        message = JSON_stringify(message);
        if (callback) {
            messageID = Math.random();
            response_callbacks[messageID] = callback;
        }

        /* If a message is initialized from main, go down. Otherwise, let the message bubble upwards */
        var direction = CONTEXT == 'main' ? 'down' : 'up';
        var packet = {
            path: [],
            direction: direction,
            isResponse: false,
            messageID: messageID,
            message: message
        };
        deliverPacket(packet);
    }

    function deliverPacket(packet) {
        /*globals CustomEvent*/
        if (packet.isResponse) {
            if (packet.path[packet.path.length - 1] != THIS_CHANNEL_ID) {
                console.log('Unexpected path, dropped packet.'); // TODO: Remove this
                return;
            }
            packet.path.pop();
        } else {
            packet.path.push(THIS_CHANNEL_ID);
        }

        if (isBetweenChannelEnds && packet.direction == 'down' ||
            CONTEXT == 'page' && packet.direction == 'up') {
            var evt = new CustomEvent(channelName + channelSuffix, {
                detail: JSON.stringify(packet)
            });
            document.dispatchEvent(evt);
        } else if (port) {
            port.emit(channelName, packet);
        } else {
            console.warn('Port not set, unable to deliver message!');
        }
    }
    function receivePacket(packet) {
        if (isAtBottomOfChannel || CONTEXT == 'main') {
            var message = JSON.parse(packet.message);
            if (packet.isResponse) {
                var callback = response_callbacks[packet.messageID];
                if (callback) {
                    delete response_callbacks[packet.messageID];
                    callback(message);
                }
            } else {
                if (packet.messageID) {
                    // Add current channel to path to ensure that it can be returned
                    packet.path.push(THIS_CHANNEL_ID);
                    packagePaths[packet.messageID] = packet.path;
                }
                onMessage.dispatch(message, packet.messageID);
            }
        } else { // CONTEXT == 'content script'
            deliverPacket(packet);
        }
    }

    if (CONTEXT == 'main' || CONTEXT == 'content script') {
        // Allow callers to change the port. Use case: Bind a new worker after replacing a Panel.
        Object.defineProperty(extension, 'port', {
            get: function() {
                return port;
            },
            set: function(newPort) {
                if (port && port.off) port.off(channelName, receivePacket);
                // Duck-typing EventEmitter
                if (!newPort || !newPort.on || !newPort.emit) newPort = null;
                port = newPort;
                if (port) port.on(channelName, receivePacket);
            },
            enumerable: false
        });
        extension.port = port; // Trigger validation of port
    }

    if (endAtPage && (CONTEXT == 'page' || CONTEXT == 'content script')) {
        // Only react to the relevant message:
        // If page, only react to messages which go down
        // If content script, only pick up messages which go up.
        var expectedDirection = CONTEXT == 'page' ? 'down' : 'up';
        document.addEventListener(channelName + channelSuffix, function(e) {
            var packet = JSON.parse(e.detail);
            if (packet.direction == expectedDirection) {
                receivePacket(packet);
            }
        });
    }

    if (endAtPage && CONTEXT == 'content script') {
        // Set up API for page
        document.documentElement.setAttribute('onreset', 
            'document.documentElement.removeAttribute("onreset");' +
            '(' + createMessageChannel + ')(' + JSON.stringify({channelName: channelName + channelSuffix}) + ');'
        );
        document.documentElement.onreset();
    }
    if (isAtBottomOfChannel) {
        window.extension = extension; // Export to global scope
    }
    
    return extension;
}
